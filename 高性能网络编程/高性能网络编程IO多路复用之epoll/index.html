<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高性能网络编程IO多路复用之epoll | hsuwindowBlogs</title><meta name="author" content="hsuwindow"><meta name="copyright" content="hsuwindow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="epoll的性能是最好的，即使在监听多达 10000 个文件描述符的情况下，其性能和监听 10 个文件描述符相比，差别也不大。而随着文件描述符的增大，select和 poll的性能逐渐变得很差。 1. epoll的使用首先，通过编写一个聊天室服务器的例子认识一下epoll。 使用epoll编写网络程序需要三个步骤：分别是epoll_create&#96;&#96;epoll_ctl和epoll_wait。接下来，">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能网络编程IO多路复用之epoll">
<meta property="og:url" content="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/index.html">
<meta property="og:site_name" content="hsuwindowBlogs">
<meta property="og:description" content="epoll的性能是最好的，即使在监听多达 10000 个文件描述符的情况下，其性能和监听 10 个文件描述符相比，差别也不大。而随着文件描述符的增大，select和 poll的性能逐渐变得很差。 1. epoll的使用首先，通过编写一个聊天室服务器的例子认识一下epoll。 使用epoll编写网络程序需要三个步骤：分别是epoll_create&#96;&#96;epoll_ctl和epoll_wait。接下来，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hsuwindow.vip/img/ubuntu_icon.png">
<meta property="article:published_time" content="2025-06-03T07:22:32.000Z">
<meta property="article:modified_time" content="2025-06-24T05:05:46.643Z">
<meta property="article:author" content="hsuwindow">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hsuwindow.vip/img/ubuntu_icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高性能网络编程IO多路复用之epoll',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-24 13:05:46'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ubuntu_icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">hsuwindowBlogs</span></a><a class="nav-page-title" href="/"><span class="site-name">高性能网络编程IO多路复用之epoll</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">高性能网络编程IO多路复用之epoll</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-03T07:22:32.000Z" title="发表于 2025-06-03 15:22:32">2025-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-24T05:05:46.643Z" title="更新于 2025-06-24 13:05:46">2025-06-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">高性能网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>epoll</code>的性能是最好的，即使在监听多达 10000 个文件描述符的情况下，其性能和监听 10 个文件描述符相比，差别也不大。而随着文件描述符的增大，<code>select</code>和 <code>poll</code>的性能逐渐变得很差。</p>
<h2 id="1-epoll的使用"><a href="#1-epoll的使用" class="headerlink" title="1. epoll的使用"></a>1. <code>epoll</code>的使用</h2><p>首先，通过编写一个聊天室服务器的例子认识一下<code>epoll</code>。</p>
<p>使用<code>epoll</code>编写网络程序需要三个步骤：分别是<code>epoll_create``epoll_ctl</code>和<code>epoll_wait</code>。接下来，我们详细讲解一下这三个 API。</p>
<h3 id="1-1-epoll-create"><a href="#1-1-epoll-create" class="headerlink" title="1.1 epoll_create()"></a>1.1 <code>epoll_create()</code></h3><p><code>epoll_create()</code>函数会创建一个 epoll 实例，并返回一个文件描述符指向该 epoll 实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: a file descriptor if OK; -1 on error and errno is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<p><code>size</code>: 自Linux 2.6.8，参数<code>size</code>将被忽略，但是仍需传入一个大于 0 的整数。</p>
<blockquote>
<p>这其实是一个历史包袱：在早期的<code>epoll_create</code>实现中，<code>size</code>参数表示应用程序期望监控的文件描述符的数量，然后内核会根据<code>size</code>来初始化内核的数据结构。但在新的实现中，内核可以动态分配所需的数据结构，因此就不再需要这个参数了。我们只需注意，将<code>size</code>设置成一个大于 0 的整数就可以了。</p>
</blockquote>
<h3 id="1-2-epoll-ctl"><a href="#1-2-epoll-ctl" class="headerlink" title="1.2 epoll_ctl"></a>1.2 <code>epoll_ctl</code></h3><p><code>epoll_ctl()</code>函数是 epoll 的控制接口，它可以往 epoll 实例中添加一个文件描述符，从epoll 实例中删除一个文件描述符，或者修改和某个文件描述符关联的事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if OK; -1 on error and errno is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>epfd</code>: 指向 epoll 实例的文件描述符。</p>
<p><code>op</code>: 操作，可取值有<code>EPOLL_CTL_ADD``EPOLL_CTL_MOD``EPOLL_CTL_DEL</code>。</p>
<p><code>fd</code>: 要添加、修改或删除的文件描述符。</p>
<p><code>event</code>: 与文件描述符<code>fd</code>关联的事件。如果<code>op</code>的值为<code>EPOLL_CTL_DEL</code>，<code>event</code>参数则被忽略。<code>struct epoll_event</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span> </span><br><span class="line">		<span class="type">uint32_t</span>     events;  <span class="comment">/* Epoll events */</span> </span><br><span class="line">		<span class="type">epoll_data_t</span> data;    <span class="comment">/* User data variable */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span> </span><br><span class="line">		<span class="type">void</span> *ptr; </span><br><span class="line">		<span class="type">int</span> fd; </span><br><span class="line">		<span class="type">uint32_t</span> u32; </span><br><span class="line">		<span class="type">uint64_t</span> u64; </span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>首先，我们来看一下<code>struct epoll_event</code>的<code>events</code>成员，它表示监视事件的类型，常见的取值有以下几种：</p>
<ul>
<li><p><code>EPOLLIN</code>: 所关联的文件可读。</p>
</li>
<li><p><code>EPOLLOUT</code>: 所关联的文件可写。</p>
</li>
<li><p><code>EPOLLRDHUP</code>: 适用于stream socket，表示对方已关闭连接，或者对方关闭了写端。</p>
</li>
<li><p><code>EPOLLET</code>: 设置该文件监听的事件为边缘触发（edge-triggered），默认为水平触发（level-triggered）。(边缘触发和水平触发的区别，下面会将…）</p>
</li>
</ul>
<p><code>struct epoll_event</code>的<code>data</code>成员是用户自己设置的数据。我们一般会设置这个联合（union）里的<code>fd</code>字段，将其设置为所关联的文件描述符<code>fd</code>。</p>
<h3 id="1-3-epoll-wait"><a href="#1-3-epoll-wait" class="headerlink" title="1.3 epoll_wait"></a>1.3 <code>epoll_wait</code></h3><p><code>epoll_wait()</code>函数类似之前讲过的<code>select()</code>和<code>poll()</code>，等待内核 I&#x2F;O 事件的分发。如果没有事件就绪，调用线程则会被挂起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: number of ready file descriptors if Ok;</span></span><br><span class="line"><span class="comment">//          0 on timeout; –1 on error and errno is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>epfd</code>: 指向 epoll 实例的文件描述符。</p>
<p><code>events</code>: 这是一个数组，当<code>epoll_wait()</code>返回的时候，里面存放的就是已经就绪的事件。</p>
<p><code>maxevents</code>: <code>epoll_wait()</code>可以返回的最大事件数目，一般设置<code>events</code>数组的长度。</p>
<p><code>timeout</code>: 超时时间 (ms)。-1 表示永久等待，0 表示立马返回，不等待。</p>
<h2 id="2-经典示例——聊天室"><a href="#2-经典示例——聊天室" class="headerlink" title="2. 经典示例——聊天室"></a>2. 经典示例——聊天室</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_chatroom.c </span></span><br><span class="line"><span class="comment">// 为了方便，省略了错误处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/bitmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT <span class="string">&quot;12123&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> listenfd = tcp_listen();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* track all file descriptors that epoll instance monitors */</span></span><br><span class="line">    bitmap* bm = bitmap_create(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create epoll instance</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="keyword">if</span> ((epfd = epoll_create(<span class="number">1</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the listener to `epfd`</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listenfd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bitmap_set(bm, listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = epoll_wait(epfd, events, MAXEVENTS, <span class="number">-1</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            error(<span class="number">0</span>, errno, <span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// run through `events` for new connection and data to read </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="comment">// something went wrong </span></span><br><span class="line">                error(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;epoll error on socket %d&quot;</span>, sockfd);</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                bitmap_unset(bm, sockfd);</span><br><span class="line">                close(sockfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="comment">// listener is ready to read, handle new connection</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_storage cliaddr;</span><br><span class="line">                <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;addrlen);</span><br><span class="line">                <span class="keyword">if</span> (connfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    error(<span class="number">0</span>, errno, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    event.data.fd = connfd;</span><br><span class="line">                    event.events = EPOLLIN;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line">                    bitmap_set(bm, connfd);</span><br><span class="line"></span><br><span class="line">                    <span class="type">char</span> ipstr[<span class="number">50</span>];</span><br><span class="line">                    inet_ntop(cliaddr.ss_family, get_ip_addr(&amp;cliaddr), ipstr, <span class="number">50</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;INFO: new connection from %s on socket %d\n&quot;</span>, ipstr, connfd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// handle data from a client</span></span><br><span class="line">                <span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">                <span class="type">int</span> n;</span><br><span class="line">                <span class="keyword">if</span> ((n = recv(sockfd, recvline, MAXLINE, <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// connection closed by client</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;INFO: socket %d hung up\n&quot;</span>, sockfd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        error(<span class="number">0</span>, errno, <span class="string">&quot;recv&quot;</span>);    <span class="comment">// something wrong</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// remove from `epfd`</span></span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    bitmap_unset(bm, sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// got some data from a client</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; bm-&gt;bits; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bitmap_isset(bm, j) &amp;&amp; j != listenfd &amp;&amp; j != sockfd) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (send(j, recvline, n, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                                error(<span class="number">0</span>, errno, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-水平触发-VS-边缘触发"><a href="#3-水平触发-VS-边缘触发" class="headerlink" title="3. 水平触发 VS 边缘触发"></a>3. 水平触发 VS 边缘触发</h2><p><em>水平触发</em>(level-triggered)和<em>边缘触发</em>(edge-triggered)这两个术语来自于电子电路科学。其中水平触发的意思是，一个信号的持续状态(而不是其变化)触发某个事件的发生，比如如果有数据可读，就会一直触发<code>EPOLLIN</code>事件。</p>
<p>而边缘触发的意思是，事件是由信号的变化触发的，而不是由信号的持续状态触发。举个例子，再边缘触发机制下，当数据到达时，会触发<code>EPOLLIN</code>事件；尽管这些数据没有被读取，之后也不会再触发<code>EPOLLIN</code>事件了。[demo演示]</p>
<p>边缘触发会导致一些小问题：明明有数据可读，却不会触发<code>EPOLLIN</code>事件，导致应用程序陷入阻塞。为了避免这类现象发生，边缘触发往往会配合非阻塞I&#x2F;O一起使用，最佳实践如下：</p>
<ol>
<li><p>配合非阻塞I&#x2F;O使用。</p>
</li>
<li><p>一直<code>read</code>和<code>write</code>，直到这两个操作返回<code>EAGAIN</code>。</p>
</li>
</ol>
<p>💬</p>
<p>Q: So, 水平触发和边缘触发哪个会更好呢？ A: 一般来说，我们认为边缘触发的效率会更高，因为它可以有效地减少事件触发的次数。但是相应的代码复杂性也会更高，因为它得配合非阻塞I&#x2F;O一起使用，并且我们得一直读和写，直到返回<code>EAGAIN</code>。而在水平触发模式(默认)，<code>epoll</code>仅仅是一个更高效版本的<code>poll</code>。</p>
<p>**<code>epoll</code>**的边缘触发模式是构建高性能服务器的有力杀手锏之一。</p>
<h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p><code>epoll</code>的出现，为Linux高性能网络编程补齐了最后一块拼图。<code>epoll</code>避免了用户态—内核态频繁的数据拷贝，大大提高了性能。在使用<code>epoll</code>的时候，我们一定要理解条件触发和边缘触发两种模式。其中边缘触发模式是构建高性能服务器的有力杀手锏之一，著名的http服务器nginx就是基于这种模式构建的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://hsuwindow.vip">hsuwindow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/">http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://hsuwindow.vip" target="_blank">hsuwindowBlogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post-share"><div class="social-share" data-image="/img/ubuntu_icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BThe%20C10K%20problem/" title="高性能网络编程The C10K problem"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">高性能网络编程The C10K problem</div></div><div class="info-2"><div class="info-item-1">借着 C10K 问题一起探讨下高性能网络编程的几种方法。 9.1 The C10K problemC10K 问题是由一个叫 Dan Kegel 的工程师提在 1999 年提出来的：如何在一台物理机上，同时保持 10000 条连接(concurrently handling ten thousand connections)。 当然，在现在的条件下，我们使用 libevent 或者 Java Netty 等框架轻轻松松就可以写出支持并发数量超过一万的服务器，经过优化之后，甚至可以达到十万，乃至百万。但在 2000 年左右，解决 C10K 问题可是一个了不起的成就。  现在的问题称为C10M，也就是如何在一台物理机上同时保持一千万条连接！  我们首先来看一下，在系统资源层面是否能够同时支持 10000 条连接(TCP 连接)。  Q: 同时支持 10000 条连接需要大量消耗哪些资源呢？ A: 文件描述符，内存，网络带宽。  文件描述符 每个客户端连接都需要在服务器上占用一个文件描述符。一旦文件描述符不够用了，新的连接就会被丢弃。在 Linux...</div></div></div></a><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/" title="高性能网络编程TCP编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">高性能网络编程TCP编程</div></div><div class="info-2"><div class="info-item-1">1. C&#x2F;S 网络编程模型C&#x2F;S 模型在我们日常生活中随处可见，比如网上购物，游戏，聊天等等软件，用的都是 C&#x2F;S 模型。C&#x2F;S 模型比较简单，它的一般流程如下图所示：   当一个客户端需要某个服务时，它会像对应的服务器发送一个请求。请求的格式是事先双方约定好的，以保证服务器可以解析这个请求。  服务器接收到请求后，会解析并处理这个请求。  服务器处理完请求后，会给客户端发送一个响应。响应可以是处理后的结果，也可以是指引客户端下一步操作的指示。  客户端接收到响应后，会解析响应并处理响应（当然客户端也可能什么都不做）。   服务器端是我们要关注的重点。它需要事先监听在一个众所周知的端口上，然后等待客户端的请求。一旦有客户端连接，服务器端就要消耗一定的计算机资源为它服务。服务器端是需要同时为成千上万的客户端服务的，因此，保证服务器端在海量的客户端访问时依然能保持稳定和高效，就至关重要。 客户端相对来说简单许多，它向服务器的监听端口发起连接请求。连接建立之后，他就可以和服务器端进行通信了。 2....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/" title="高性能网络编程TCP编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">高性能网络编程TCP编程</div></div><div class="info-2"><div class="info-item-1">1. C&#x2F;S 网络编程模型C&#x2F;S 模型在我们日常生活中随处可见，比如网上购物，游戏，聊天等等软件，用的都是 C&#x2F;S 模型。C&#x2F;S 模型比较简单，它的一般流程如下图所示：   当一个客户端需要某个服务时，它会像对应的服务器发送一个请求。请求的格式是事先双方约定好的，以保证服务器可以解析这个请求。  服务器接收到请求后，会解析并处理这个请求。  服务器处理完请求后，会给客户端发送一个响应。响应可以是处理后的结果，也可以是指引客户端下一步操作的指示。  客户端接收到响应后，会解析响应并处理响应（当然客户端也可能什么都不做）。   服务器端是我们要关注的重点。它需要事先监听在一个众所周知的端口上，然后等待客户端的请求。一旦有客户端连接，服务器端就要消耗一定的计算机资源为它服务。服务器端是需要同时为成千上万的客户端服务的，因此，保证服务器端在海量的客户端访问时依然能保持稳定和高效，就至关重要。 客户端相对来说简单许多，它向服务器的监听端口发起连接请求。连接建立之后，他就可以和服务器端进行通信了。 2....</div></div></div></a><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BThe%20C10K%20problem/" title="高性能网络编程The C10K problem"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-04</div><div class="info-item-2">高性能网络编程The C10K problem</div></div><div class="info-2"><div class="info-item-1">借着 C10K 问题一起探讨下高性能网络编程的几种方法。 9.1 The C10K problemC10K 问题是由一个叫 Dan Kegel 的工程师提在 1999 年提出来的：如何在一台物理机上，同时保持 10000 条连接(concurrently handling ten thousand connections)。 当然，在现在的条件下，我们使用 libevent 或者 Java Netty 等框架轻轻松松就可以写出支持并发数量超过一万的服务器，经过优化之后，甚至可以达到十万，乃至百万。但在 2000 年左右，解决 C10K 问题可是一个了不起的成就。  现在的问题称为C10M，也就是如何在一台物理机上同时保持一千万条连接！  我们首先来看一下，在系统资源层面是否能够同时支持 10000 条连接(TCP 连接)。  Q: 同时支持 10000 条连接需要大量消耗哪些资源呢？ A: 文件描述符，内存，网络带宽。  文件描述符 每个客户端连接都需要在服务器上占用一个文件描述符。一旦文件描述符不够用了，新的连接就会被丢弃。在 Linux...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ubuntu_icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">hsuwindow</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临本站,这是我日常工作和学习整理的总结,希望对你有所帮助.本站内容经过个人加工总结而来,也参考了网友们分享的资料,如有侵权,请第一时间联系我,我将及时进行修改或删除.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-epoll%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1. epoll的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-epoll-create"><span class="toc-text">1.1 epoll_create()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-epoll-ctl"><span class="toc-text">1.2 epoll_ctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-epoll-wait"><span class="toc-text">1.3 epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%8F%E5%85%B8%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-text">2. 经典示例——聊天室</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-VS-%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="toc-text">3. 水平触发 VS 边缘触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93"><span class="toc-text">归纳总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%A2%98%E8%A7%A3/" title="哈希表题解">哈希表题解</a><time datetime="2025-06-10T03:08:20.000Z" title="发表于 2025-06-10 11:08:20">2025-06-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BThe%20C10K%20problem/" title="高性能网络编程The C10K problem">高性能网络编程The C10K problem</a><time datetime="2025-06-04T09:42:31.000Z" title="发表于 2025-06-04 17:42:31">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/" title="高性能网络编程IO多路复用之epoll">高性能网络编程IO多路复用之epoll</a><time datetime="2025-06-03T07:22:32.000Z" title="发表于 2025-06-03 15:22:32">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/" title="高性能网络编程TCP编程">高性能网络编程TCP编程</a><time datetime="2025-06-01T02:12:21.000Z" title="发表于 2025-06-01 10:12:21">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" title="贪心算法题解">贪心算法题解</a><time datetime="2025-05-30T02:28:30.000Z" title="发表于 2025-05-30 10:28:30">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By hsuwindow</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>