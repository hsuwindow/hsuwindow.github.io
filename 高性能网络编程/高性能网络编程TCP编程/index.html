<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高性能网络编程TCP编程 | hsuwindowBlogs</title><meta name="author" content="hsuwindow"><meta name="copyright" content="hsuwindow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. C&#x2F;S 网络编程模型C&#x2F;S 模型在我们日常生活中随处可见，比如网上购物，游戏，聊天等等软件，用的都是 C&#x2F;S 模型。C&#x2F;S 模型比较简单，它的一般流程如下图所示：   当一个客户端需要某个服务时，它会像对应的服务器发送一个请求。请求的格式是事先双方约定好的，以保证服务器可以解析这个请求。  服务器接收到请求后，会解析并处理这个请求。  服务器处理完请求">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能网络编程TCP编程">
<meta property="og:url" content="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="hsuwindowBlogs">
<meta property="og:description" content="1. C&#x2F;S 网络编程模型C&#x2F;S 模型在我们日常生活中随处可见，比如网上购物，游戏，聊天等等软件，用的都是 C&#x2F;S 模型。C&#x2F;S 模型比较简单，它的一般流程如下图所示：   当一个客户端需要某个服务时，它会像对应的服务器发送一个请求。请求的格式是事先双方约定好的，以保证服务器可以解析这个请求。  服务器接收到请求后，会解析并处理这个请求。  服务器处理完请求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hsuwindow.vip/img/ubuntu_icon.png">
<meta property="article:published_time" content="2025-06-01T02:12:21.000Z">
<meta property="article:modified_time" content="2025-06-24T06:22:59.694Z">
<meta property="article:author" content="hsuwindow">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hsuwindow.vip/img/ubuntu_icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高性能网络编程TCP编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-24 14:22:59'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ubuntu_icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">hsuwindowBlogs</span></a><a class="nav-page-title" href="/"><span class="site-name">高性能网络编程TCP编程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">高性能网络编程TCP编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-01T02:12:21.000Z" title="发表于 2025-06-01 10:12:21">2025-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-24T06:22:59.694Z" title="更新于 2025-06-24 14:22:59">2025-06-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">高性能网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-C-S-网络编程模型"><a href="#1-C-S-网络编程模型" class="headerlink" title="1. C&#x2F;S 网络编程模型"></a>1. C&#x2F;S 网络编程模型</h2><p>C&#x2F;S 模型在我们日常生活中随处可见，比如网上购物，游戏，聊天等等软件，用的都是 C&#x2F;S 模型。C&#x2F;S 模型比较简单，它的一般流程如下图所示：</p>
<p><img src="https://hsuwindow-blogs.oss-cn-beijing.aliyuncs.com/2025/06/01-01/202506241408623.png" alt="image-20250624140831553"></p>
<ol>
<li><p>当一个客户端需要某个服务时，它会像对应的服务器发送一个请求。请求的格式是事先双方约定好的，以保证服务器可以解析这个请求。</p>
</li>
<li><p>服务器接收到请求后，会解析并处理这个请求。</p>
</li>
<li><p>服务器处理完请求后，会给客户端发送一个响应。响应可以是处理后的结果，也可以是指引客户端下一步操作的指示。</p>
</li>
<li><p>客户端接收到响应后，会解析响应并处理响应（当然客户端也可能什么都不做）。</p>
</li>
</ol>
<p><strong>服务器端</strong>是我们要关注的重点。它需要事先监听在一个众所周知的端口上，然后等待客户端的请求。一旦有客户端连接，服务器端就要消耗一定的计算机资源为它服务。服务器端是需要同时为成千上万的客户端服务的，因此，保证服务器端在海量的客户端访问时依然能保持稳定和高效，就至关重要。</p>
<p>客户端相对来说简单许多，它向服务器的监听端口发起连接请求。连接建立之后，他就可以和服务器端进行通信了。</p>
<h2 id="2-socket"><a href="#2-socket" class="headerlink" title="2. socket()"></a>2. <code>socket()</code></h2><p>客户端和服务器端要进行通信，第一件要做的事情就是双方创建通信端点。那怎么创建通信端点呢？答案是<code>socket()</code>，它会创建一个通信端点，并返回一个指向该端点的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: a file descriptor if OK; -1 on error and errno is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>domain</code>: 是用来指定协议族的。<code>AF_INET</code>表示 IPv4 互联网协议；<code>AF_INET6</code>表示 IPv6 互联网协议；<code>AF_UNIX</code>和<code>AF_LOCAL</code>用来本地通信的。</p>
<p><code>type</code>: 套接字的类型。<code>SOCK_STREAM</code>表示字节流套接字，<code>SOCK_DGRAM</code>表示数据报套接字。</p>
<p><code>protocol</code>: 设计之初原本是用来指定通信协议的，但现在基本没用，因为现在前面两个参数<code>domain</code>和<code>type</code>就可以唯一确定一个协议。<code>protocol</code>目前填 0 即可。</p>
<p><strong>Example</strong></p>
<p>如果你记不住这些参数也不碍事，我们只需要把调用<code>getaddrinfo()</code>的结果，传递给<code>socket()</code>就可以了。就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [pretend we already filled out the `hints` struct]</span></span><br><span class="line"><span class="comment">// do the lookup</span></span><br><span class="line">getaddrinfo(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="string">&quot;http&quot;</span>, &amp;hints, &amp;result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// You should walk the `result` linked list looking for valid entries, </span></span><br><span class="line"><span class="comment">// instead of just assuming the first one is good (like the example do).</span></span><br><span class="line"><span class="type">int</span> sock_fd = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>The old-school way</strong> 以前我们是这样调用<code>socket()</code>函数的：<code>int sock_fd = socket(AF_INET, SOCK_STREAM, 0)</code>。这样做有一个很大的弊端，就是它是硬编码的。我们经常不知道我们写的程序会部署在怎样的环境下。</p>
</blockquote>
<h2 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. <code>bind()</code></h2><p>服务器需要监听在一个众所周知的端口，因此，我们需要给刚刚创建的通信端点绑定一个众所周知的地址。<code>bind()</code>函数就是用来做这件事情的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if Ok; -1 on failure, and `errno` is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>sockfd</code>: 关联 “socket 文件”（通信端点）的文件描述符。</p>
<p><code>addr</code>: 要绑定的套接字地址。</p>
<p><code>addrlen</code>: 套接字地址的长度。</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">result</span>;</span></span><br><span class="line"><span class="comment">// fill out hints</span></span><br><span class="line">bzero(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">hints.ai_family = AF_UNSPEC;      <span class="comment">// use IPv4 or IPv6, whichever</span></span><br><span class="line">hints.ai_socktype = SOCK_STREAM;  <span class="comment">// TCP only</span></span><br><span class="line">hints.ai_flags = AI_PASSIVE;      <span class="comment">// wildcard address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When used with wildcard address, `node` must be NULL.</span></span><br><span class="line"><span class="comment">// Otherwise `AI_PASSIVE` flag is ignored.</span></span><br><span class="line">getaddrinfo(<span class="literal">NULL</span>, <span class="string">&quot;9527&quot;</span>, &amp;hints, &amp;result); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock_fd = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind a address to `sock_fd`</span></span><br><span class="line">bind(sock_fd, result-&gt;ai_addr, result-&gt;ai_addrlen);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>通配符地址（wildcard address）</strong> 服务器端一般用得都是通配符地址，这样服务器就可以接收来自各个网卡的连接。在老的代码中，指定通配符地址要麻烦许多。 IPv4: <code>addr.sin_addr.s_addr = htonl(INADDR_ANY);</code> IPv6: <code>addr.sin6_addr = in6addr_any; </code>感谢<code>getaddrinfo()</code>，让我们省去了这些麻烦！</p>
</blockquote>
<p>注意，不要绑定 1024 以下的端口。这些端口是系统保留端口，需要超级用户权限才能使用。</p>
<p>另一个要注意的事项是，<code>bind()</code>函数可能会失败，并返回 “Address already in use” 错误。出现这个错误的原因有多个，其中一个常见的原因就是上一次断开的连接还处于<code>TIME_WAIT</code>状态。如果你想在<code>TIME_WAIT</code>状态也可以重用原来的端口，那么需要设置套接字的<code>SO_REUSEADDR</code>选项。在 C 语言中，我们是这样做的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt_value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Reuse port number even though connection in `TIME_WAIT` status.</span></span><br><span class="line">setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt_value, <span class="keyword">sizeof</span>(opt_value));</span><br></pre></td></tr></table></figure>

<h2 id="4-listen"><a href="#4-listen" class="headerlink" title="4. listen()"></a>4. <code>listen()</code></h2><p><code>socket()</code>函数创建的套接字，是一个主动套接字，它可以主动发送请求，也可以和另一个主动套接字传输数据。</p>
<p><code>listen()</code>函数可以将原来的主动套接字转换为被动套接字，被动套接字是用来等待用户请求的。操作系统会为被动套接字创建一些用来接收用户请求的数据结构，比如半连接队列和已连接队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if Ok; -1 on failure, and `errno` is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>sockfd</code>: 主动套接字的文件描述符。</p>
<p><code>backlog</code>: 在 Linux 中，<code>backlog</code>表示已连接队列的最大大小。</p>
<h2 id="5-accept"><a href="#5-accept" class="headerlink" title="5. accept()"></a>5. <code>accept()</code></h2><p><code>accept()</code>函数会从已连接队列中接收一条连接，并为其创建一个 socket 文件用于通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: a file descriptor for accepted socket if Ok; </span></span><br><span class="line"><span class="comment">//          -1 on failure and `errno` is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>listenfd</code>: 被动套接字的文件描述符，用于监听连接的。</p>
<p><code>addr</code>: 用于接收远端的地址。通常<code>addr</code>会指向一个<code>struct sockaddr_storage</code>结构体。</p>
<p><code>addrlen</code>: 这是一个传入传出参数，传入的时候，它会告诉内核addr的实际长度，避免缓冲区溢出。传出的时候，它会告诉应用程序远端地址的实际长度：IPv4 为 16，IPv6 为 28。</p>
<p><strong>Example</strong></p>
<p>至此，服务器端主要函数就介绍完了。我们一起来看一下服务器端的主要流程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了错误处理</span></span><br><span class="line"><span class="comment">// server.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT <span class="string">&quot;9527&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints, *result;</span><br><span class="line">    <span class="comment">// fill out `hints`</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;hints, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;        <span class="comment">// use IPv4 or IPv6, whichever</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;    <span class="comment">// TCP only</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE;        <span class="comment">// wildcard address</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getaddrinfo</span>(<span class="literal">NULL</span>, PORT, &amp;hints, &amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a socket, bind it, and listen on it.</span></span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br><span class="line">    <span class="built_in">bind</span>(listen_fd, result-&gt;ai_addr, result-&gt;ai_addrlen);</span><br><span class="line">    <span class="built_in">listen</span>(listen_fd, BACKLOG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, ready to accept an incoming connection.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> conn_fd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ready to communicate on socket descriptor `conn_fd`</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-connect"><a href="#6-connect" class="headerlink" title="6. connect()"></a>6. <code>connect()</code></h2><p>上面描述的是服务器端的流程，客户端的流程要简单许多。</p>
<p>第一步和服务器端一样，调用<code>socket()</code>创建一个套接字。第二步，客户端需要调用<code>connect()</code>向服务器端发起连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if Ok; -1 on failure and `errno` is set.</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>sockfd</code>: 客户端套接字。</p>
<p><code>addr</code>: 服务器端的地址。</p>
<p><code>addrlen</code>: 服务器端地址的长度。</p>
<p><strong>Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了教学的目的，省略了错误处理</span></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT <span class="string">&quot;9527&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">result</span>;</span></span><br><span class="line">    <span class="comment">// fill out `hints`</span></span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;        <span class="comment">// use IPv4 or IPv6, whichever</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;    <span class="comment">// TCP only</span></span><br><span class="line">		<span class="comment">// get the address of server</span></span><br><span class="line">    getaddrinfo(<span class="string">&quot;127.0.0.1&quot;</span>, SERV_PORT, &amp;hints, &amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a socket</span></span><br><span class="line">    <span class="type">int</span> sock_fd = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initiate a connection to server</span></span><br><span class="line">    connect(sock_fd, result-&gt;ai_addr, result-&gt;ai_addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ready to communicate on socket descriptor `sock_fd`</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，客户端调用<code>connect()</code>之前，可以但没有必要去调用<code>bind()</code>。因为内核会自动确定 IP 地址，并选择一个可用的端口。</p>
<p>如果是<code>SOCK_STREAM</code>类型的套接字，调用<code>connect()</code>将激发 TCP 的三次握手过程，且仅在连接建立成功或出错时才会返回。</p>
<h3 id="6-1-TCP-的三次握手"><a href="#6-1-TCP-的三次握手" class="headerlink" title="6.1 TCP 的三次握手"></a>6.1 TCP 的三次握手</h3><p>接下来，一起来看一下著名的 TCP 三次握手过程。</p>
<p><img src="https://hsuwindow-blogs.oss-cn-beijing.aliyuncs.com/2025/06/01-01/202506241421402.png" alt="image-20250624142138266"></p>
<p>注意，默认情况下 socket 网络编程都是阻塞式的，当然也有非阻塞式的，我们在后面的章节会讲。所谓阻塞式就是应用程序发起函数调用后不会直接返回，由操作系统内核处理完成之后才会返回。</p>
<p><strong>解读</strong></p>
<p>服务器端调用<code>socket()</code>，<code>bind()</code>和<code>listen()</code>完成了被动套接字的准备工作，所谓”被动“就是等待客户端来连接。然后调用<code>accept()</code>去接收已建立的连接，如果没有已建立的连接，<code>accept()</code>就会陷入阻塞。</p>
<p>客户端调用<code>socket()</code>完成主动套接字的准备工作。然后调用<code>connect()</code>主动发起连接请求，这时候就会触发 TCP 的三次握手过程，<code>connect()</code>陷入阻塞。</p>
<p>接下来的事情就由操作系统内核的网络协议栈完成，具体过程如下：</p>
<ol>
<li>客户端的网络协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号为 j，客户端进入<code>SYNC_SENT</code>状态。</li>
<li>服务器端的网络协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示对 SYN 包 j 的确认；同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 k，服务器端进入<code>SYN_RCVD</code>状态。</li>
<li>客户端网络协议栈收到 ACK 之后，就会让应用程序从<code>connect()</code>调用返回。客户端到服务器端的单向连接也就建立成功了，客户端进入<code>ESTABLISHED</code>状态。同时客户端网络协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1。</li>
<li>应答包到达服务器端后，服务器端网络协议栈会让<code>accept()</code>调用返回。这时服务器端到客户端的单向连接也建立成功，服务器端也进入<code>ESTABLISHED</code>状态。</li>
</ol>
<h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p>这一章，我们主要讲了服务器端和客户端的建立连接的主要流程，并且结合 socket 网络编程详细讲解了 TCP 的三次握手。</p>
<ul>
<li><p>服务器端通过<code>socket()</code>，<code>bind()</code>，<code>listen()</code>完成被动套接字的准备工作；通过<code>accept()</code>函数接收已建立的连接。</p>
</li>
<li><p>客户端通过<code>socket()</code>完成主动套接字的准备工作；通过<code>connect()</code>主动发起连接请求。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://beej.us/guide/bgnet/">Beej’s Guide to Network Programming</a></p>
</li>
<li><p>TCP&#x2F;IP Illustrated, Volume 1: The Protocols</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://hsuwindow.vip">hsuwindow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/">http://hsuwindow.vip/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTCP%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://hsuwindow.vip" target="_blank">hsuwindowBlogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post-share"><div class="social-share" data-image="/img/ubuntu_icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/" title="高性能网络编程IO多路复用之epoll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">高性能网络编程IO多路复用之epoll</div></div><div class="info-2"><div class="info-item-1">epoll的性能是最好的，即使在监听多达 10000 个文件描述符的情况下，其性能和监听 10 个文件描述符相比，差别也不大。而随着文件描述符的增大，select和 poll的性能逐渐变得很差。 1. epoll的使用首先，通过编写一个聊天室服务器的例子认识一下epoll。 使用epoll编写网络程序需要三个步骤：分别是epoll_create``epoll_ctl和epoll_wait。接下来，我们详细讲解一下这三个 API。 1.1 epoll_create()epoll_create()函数会创建一个 epoll 实例，并返回一个文件描述符指向该 epoll 实例。 12345#include &lt;sys/epoll.h&gt;int epoll_create(int size);// Returns: a file descriptor if OK; -1 on error and errno is set.  参数说明 size: 自Linux 2.6.8，参数size将被忽略，但是仍需传入一个大于 0...</div></div></div></a><a class="pagination-related" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/leetcode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" title="leetcode贪心算法题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">leetcode贪心算法题解</div></div><div class="info-2"><div class="info-item-1"> 本文是基本常见的贪心算法题解  一、贪心算法简介贪心无套路. 思考局部最优解是什么, 然后思考局部最优能不能推出全局最优(没有严格证明, 就是感觉局部最优可以推理出全局最优,同时自己还想不到反例, 那么就可以试一试贪心的策略, 仅仅是尝试) 贪心算法一般分为如下四步：  将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解  这个四步其实过于理论化了，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了. 贪心没有套路，说白了就是常识性推导加上举反例 二、贪心算法题解455. 分发饼干小饼干先喂饱小胃口 大饼干先喂饱大胃口 这两种思路都可以 下面是leetcode的解法,我第一次写也是这样的.方便好理解. 123456789101112131415161718192021class Solution &#123;public:    int findContentChildren(vector&lt;int&gt; &amp;g, vector&lt;int&gt; &amp;s) &#123;        int...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/" title="高性能网络编程IO多路复用之epoll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-03</div><div class="info-item-2">高性能网络编程IO多路复用之epoll</div></div><div class="info-2"><div class="info-item-1">epoll的性能是最好的，即使在监听多达 10000 个文件描述符的情况下，其性能和监听 10 个文件描述符相比，差别也不大。而随着文件描述符的增大，select和 poll的性能逐渐变得很差。 1. epoll的使用首先，通过编写一个聊天室服务器的例子认识一下epoll。 使用epoll编写网络程序需要三个步骤：分别是epoll_create``epoll_ctl和epoll_wait。接下来，我们详细讲解一下这三个 API。 1.1 epoll_create()epoll_create()函数会创建一个 epoll 实例，并返回一个文件描述符指向该 epoll 实例。 12345#include &lt;sys/epoll.h&gt;int epoll_create(int size);// Returns: a file descriptor if OK; -1 on error and errno is set.  参数说明 size: 自Linux 2.6.8，参数size将被忽略，但是仍需传入一个大于 0...</div></div></div></a><a class="pagination-related" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BThe%20C10K%20problem/" title="高性能网络编程The C10K problem"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-04</div><div class="info-item-2">高性能网络编程The C10K problem</div></div><div class="info-2"><div class="info-item-1">借着 C10K 问题一起探讨下高性能网络编程的几种方法。 9.1 The C10K problemC10K 问题是由一个叫 Dan Kegel 的工程师提在 1999 年提出来的：如何在一台物理机上，同时保持 10000 条连接(concurrently handling ten thousand connections)。 当然，在现在的条件下，我们使用 libevent 或者 Java Netty 等框架轻轻松松就可以写出支持并发数量超过一万的服务器，经过优化之后，甚至可以达到十万，乃至百万。但在 2000 年左右，解决 C10K 问题可是一个了不起的成就。  现在的问题称为C10M，也就是如何在一台物理机上同时保持一千万条连接！  我们首先来看一下，在系统资源层面是否能够同时支持 10000 条连接(TCP 连接)。  Q: 同时支持 10000 条连接需要大量消耗哪些资源呢？ A: 文件描述符，内存，网络带宽。  文件描述符 每个客户端连接都需要在服务器上占用一个文件描述符。一旦文件描述符不够用了，新的连接就会被丢弃。在 Linux...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ubuntu_icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">hsuwindow</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临本站,这是我日常工作和学习整理的总结,希望对你有所帮助.本站内容经过个人加工总结而来,也参考了网友们分享的资料,如有侵权,请第一时间联系我,我将及时进行修改或删除.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-S-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. C&#x2F;S 网络编程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-socket"><span class="toc-text">2. socket()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-bind"><span class="toc-text">3. bind()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-listen"><span class="toc-text">4. listen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-accept"><span class="toc-text">5. accept()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-connect"><span class="toc-text">6. connect()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">6.1 TCP 的三次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93"><span class="toc-text">归纳总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/leetcode%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" title="leetcode双指针题解">leetcode双指针题解</a><time datetime="2025-06-30T15:38:21.000Z" title="发表于 2025-06-30 23:38:21">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3/" title="leetcode动态规划题解">leetcode动态规划题解</a><time datetime="2025-06-30T15:08:20.000Z" title="发表于 2025-06-30 23:08:20">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%B0%86OpenXLSX%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%88%B0cpp%E9%A1%B9%E7%9B%AE/" title="将 OpenXLSX 库添加到 C++ 项目">将 OpenXLSX 库添加到 C++ 项目</a><time datetime="2025-06-28T16:18:02.000Z" title="发表于 2025-06-29 00:18:02">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/leetcode%E5%93%88%E5%B8%8C%E8%A1%A8%E9%A2%98%E8%A7%A3/" title="leetcode哈希表题解">leetcode哈希表题解</a><time datetime="2025-06-10T03:08:20.000Z" title="发表于 2025-06-10 11:08:20">2025-06-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BThe%20C10K%20problem/" title="高性能网络编程The C10K problem">高性能网络编程The C10K problem</a><time datetime="2025-06-04T09:42:31.000Z" title="发表于 2025-06-04 17:42:31">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By hsuwindow</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>